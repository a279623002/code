### 双循环
* 14 取第一个字符串与其他字符串比较
* 36 双循环遍历时记录到map里，超出一次即不满足条件，关键在map设计
* 41 根据条件置换数组，从0到N(数组长度遍历),不在0-N返回N+1，在0-N中位置x对不上值x就返回x
* 73 使用map(row和col)标记要更改0的位置
##### 模拟
* 54 按层模拟顺时针遍历，注意越界
* 59 54变种，注意计算下层和左层时套上一层判断，否则到最后一层时重复计算，如54
##### 单循环
* 1 map[值]下标， 如果在map找得到下标，返回其下标和当前下标，否则加入到map
* 28 取相同长度进行匹配，注意越界
* 42 每个下标先存下左右的最大高度，累加最小的高度减去当前值
* 58 注意空格处理
* 66 从后遍历加一，如果溢出把溢出值带到下一次遍历，否则结束
* 67 uint8转int，int转string
### 双指针
##### 普通双指针
* 11 max(min(h[l],h[r])*len(r-l),..), min(l,r)的指针向中间移动
* 15 枚举a固定第一个数，枚举b用双指针，根据第二个数枚举c第三个数
* 16 与15的不同在于等于和接近target值
* 18 与15相比多了一层循环
* 56 重要点在于数组的排序
* 57 在56的排序前插入数组
##### 快慢指针
* 3 滑动窗口，字符不会超过256，初始一个长度为256切片，遍历值作为切片下标，下标作为切片值，若快指针找到重复值，慢指针会更新到快指针
* 19 设链表长度l，fast走到n停，还剩l-n, slow走到l-n前停，得到目标节点前，然后跟改指向
* 26 快指针与上个值不同，慢指针就可以更新为这个值，并且前进，不用考虑超出新长度的部分
* 27 与26相同
* 76 滑动窗口，一个map记录要匹配的字符数量，另一个检查字符数量，匹配后慢指针要调到下一个匹配到的位置
* 80 26变种，需要检查slow-2与fast

### 递归
##### 分治合并
* 23 先取数组l--middle,middle+1--r合并, 再取l-mm, mm+1-middle合并和middle--mm, mm+1--r合并，直到l>=r结束
##### 回溯
* 17 可以看成树的遍历，每次遍历把累加的str带入，到最后一层后加到res
* 22 有左括号才有右括号，记录左右括号数量，右括号数量完了就是退出条件，累加结果
* 37 36的变种，先取出要填的空格下标和规则，然后递归填入数据，填入失败则回溯到遍历层进入下一次遍历
* 39 分两种情况，1是跳过当前值，2是减去当前值，当等于目标时加到res
* 40 排序后存下每个值出现的次数freq，递归时判断的是freq而不是原来的数组
* 46 记录值后剔除该值或者下次跳过该值
* 47 排序数组，从左到右填入，并记录，下个重复值判断是否已填入
* 51 同行同列同斜线只能有一个queen
* 52 51变种，不输出棋盘，统计结果
* 77 进入下一个递归时，缩进数组，直到k==0，添加结果然后回溯
* 78 在回溯后再次递归就可以达到循环的效果，(77可以这样优化，然后剪枝)
* 79 记录访问的单元格，递归上下左右时跳过，回溯时还原
##### 普通递归
* 21 哪个链表先空就返回另一条，用值小的一条开始递归，当值大于另一条，就会用另一条递归，直到链表为空
* 24 新链表下一节点 指向递归原链表的递归next.next节点
* 25 不足k返回链表，链表第一个节点反转后变为最后节点，指向递归剩余一截链表
* 38 获取上一层，记录两重复值的差然后合并
##### 类进制运算
* 29 先判断越界，记录正负，统一用正数，使用进制运算，返回递归count
* 50 不能连乘，需要像进制样拆分，在拆分中相乘结果，如x^1->x^2->x^4->x^8->x^16->x^32->x^64, 注意n是奇数的话还要额外乘x
##### 快速排序
* 75 用递归实现的快排，拿第一个元素去排序成（左边--1--右边）,然后递归左边和右边

### 二分查找
* 4 找出中间值、排开以找到的值，更新中间值，为1时说明排除到剩下两个值，取最小
* 33 将数组从中间分开成左右两部分的时候，一定有一部分的数组是有序的， 如45670123 =》456, 70123 or 45670 123
* 34 不是直接命中，需要大于或等于target
* 35 同34, 不过命中的话要直接返回
* 69 找到最接近的目标值
* 74 两次二分查找法，可以使用sort包内置方法sort.Search()
* 81 33变种，里面有重复值，需要找到有序的一边
### 中心拓展
* 5 遍历，以当前下标为中心向左右拓展，得出最大的范围
### 规律
* 6 按行读取，主列的下一个索引为+ 2*row - 2,中间列下一个索引为 + 2*row-2 - i,首行和尾行没有中间列 
* 31 下一个更大的排列是从右往左交换大小数以及升序排列得出
* 45 记录每次能跳的最大长度，达到当前能跳的位置的时候更新下一次能跳的位置
* 48 从上到下垂直翻转，对角线翻转
* 55 45变种，不记录次数，更新最大长度去判断能接着跳或是到达终点
###### 康托展开
> https://blog.csdn.net/wbin233/article/details/72998375
* 60 了解康托展开，根据规律逆推

### 数学
* 7 注意溢出范围返回0，取整取余
* 9 转一半匹配
* 12 定义个结构体，初始化时从大到小，依次减去得到结果
* 13 定义结构体，遍历字符串，加减当前字符取决于如果有后一个字符并且大于当前字符
* 43 首先需要实现字符串相加，再遍历两个数，注意要按位添加，再处理carry跟补0，直接num2[x]*num1会溢出
### 自动机
* 8 遍历字符，当前状态根据该字符转换状态
* 65 自动机规则不明，尝试多次
### 动态规划
> 动态规划的题目分为两大类，一种是求最优解类，典型问题是背包问题，另一种就是计数类，它们都存在一定的递推性质。前者的递推性质还有一个名字，叫做 「最优子结构」
* 10 边界值为true，每次遍历的结果都取决由上一个边界值的结果
* 32 ...() or ...)), 遍历中的dp如果大于结果值就更新
* 44 与10相似，但匹配是独立的，前后没有关联，dp|i|j|可看成s[0:i]与p[0:j]匹配结果集
* 53 当遍历值大于累加值,继续累加后（否则使用当前值）去比较dp
* 62 (递归超时)，边界条件dp|0|i|=1 dp|j|0|=1
* 63  62变种，可用滚动数组优化
* 64 62变种，同样不能用递归去回溯，初始化dp去拿min(dp|i|j-1|, dp|i|j-1|)
* 70 可用滚动数组，边界条件dp|0|=1, dp|n| = dp|n-1|+dp|n-2|
* 72 不需要考虑增删改后的str，当成一次次操作的次数去规划，转移动态时需要比较的是操作A(增删)、B(增删)、AB(改)
### 栈
* 20 左边括号存到栈，遇到闭合括号从栈顶拿出来匹配
* 71 切割成数组，根据条件压入或弹出
### 链表
* 2 逆序，相同位置相加，溢出的值保存到下一位相加，链表长度不一补0
* 61 计算节点数，头尾连接，在目标处断开循环
* 82 当前指向的节点与下一节点指向的节点值相同时，更新当前节点指向的节点，然后再更新当前节点
* 83 82的变种，可以用递归
### 哈希
* 49 使用sort.Slice排序，作为map的键