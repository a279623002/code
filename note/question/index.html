<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>note</title>
    <script src="../../assets/js/font.js"></script>
    <script src="../../assets/js/jquery-3.6.0.min.js"></script>
    <link rel="stylesheet" href="../../assets/css/public.css">
    <link rel="stylesheet" href="../../assets/css/note.css">
    <link rel="stylesheet" href="../../assets/css/question.css">
</head>

<body>
    <header></header>
    <main>
        <a href="javascript:void(0);" class="btn close">—</a>
        <div class="tab">
            <a href="#box1" class="active">go</a>
            <a href="#box2">mysql</a>
            <a href="#box3">redis</a>
            <a href="#box4">nginx</a>
            <a href="#box5">mongodb</a>
            <a href="#box6">rabbitMQ</a>
            <a href="#box7">设计模式</a>
            <a href="#box8">算法</a>
            <a href="#box9">项目经历</a>
            <a href="#box10">k8s</a>
            <a href="#box11">树</a>
            <a href="#box12">linux</a>
            <a href="#box13">shell</a>
            <a href="#box14">docker</a>
            <a href="#box15">casbin</a>
            <a href="#box16">协议</a>
            <a href="#box17">jwt</a>
            <a href="#box18">微服务</a>
        </div>
        <div class="content">
            <div id="box1" class="box selected">
                <p class="col">数据类型</p>
                <p class="one_indent">1. 值类型：int, float, string, bool, array, stuct</p>
                <p class="one_indent">2. 引用类型：slice, map, chan, 空接口, 指针</p>

                <p class="col">数据类型区别</p>
                <p class="one_indent">1. 值类型：变量存值，内存在栈分配</p>
                <p class="one_indent">2. 指针类型：变量存地址，地址指向值，内存在堆分配</p>

                <p class="col">变量传递是值拷贝还是引用</p>
                <p class="one_indent">取决与变量类型</p>
                <p class="one_indent">1. 值传递为值拷贝，其中<i style="color:red">切片</i>包含对底层数组的引用，在不扩容的情况会影响原始切片，
                    <i style="color:red">map</i>传递的是指向map内部数据结构的指针的拷贝，会影响原始map
                </p>
                <p class="one_indent">2。 指针传递为引用指针操作原始数据，避免不必要的拷贝，提高性能</p>

                <p class="col">new和make的区别</p>
                <p class="one_indent">1. new</p>
                <p class="one_indent">分配值类型的内存，返回指向零值的指针</p>
                <p class="one_indent">2. make</p>
                <p class="one_indent">分配引用类型的内存，初始化对应类型后返回类型</p>

                <p class="col">切片，chan，map需不需要用make以及区别</p>
                <p class="one_indent">1. 切片可以不需要make</p>
                <p class="one_indent">使用make可以指定长度与容量进行分配，其中所有元素为零值，只指定长度容量将默认为长度</p>
                <p class="one_indent">不使用make切片的长度与容量将由元素或数组范围自动确定</p>
                <p class="one_indent">2. chan需要make</p>
                <p class="one_indent">3. map可以不需要make</p>
                <p class="one_indent">使用make后映射被正确初始化，可以立即存储键值对，没有显式make则go会自动完成初始化</p>
                <p class="one_indent">不使用make该map为零值，需要显式调用make初始化才能使用</p>

                <p class="col">切片底层与扩容</p>
                <p class="one_indent">1. 切片底层为指向底层数组的指针，长度，容量</p>
                <p class="one_indent">2. 扩容机制：</p>
                <p class="one_indent">2.1 当切片容量不足时，根据版本不同go会自动扩容当前容量2倍或1.25倍</p>
                <p class="one_indent">2.2 根据计算出的容量，在堆上分配一个新的数组</p>
                <p class="one_indent">2.3 将原切片中的元素复制到新分配的数组中</p>
                <p class="one_indent">2.4 更新切片的指针指向新的数据，更新长度与容量</p>

                <p class="col">map底层与扩容</p>
                <p class="one_indent">1. map底层依赖于哈希表，底层结构体为<i style="color:red">hmap</i>，维护<i
                        style="color:red">bucket桶数组</i>，
                    bucket中元素结构为<i style="color:red">bmap</i>， bmap为bucketCnt-uint8键值对，bucket满了会放到下一个溢出桶中，
                    通过<i style="color:red">overflow</i>连接，<i style="color:red">oldbuckets</i>指向原来的桶</p>

                <p class="col">channel底层</p>
                <p class="one_indent">底层数据结构为hchan结构体</p>
                <p class="one_indent">1. qcount：当前channel中元素个数</p>
                <p class="one_indent">2. dataqsiz：环形缓冲区的容量</p>
                <p class="one_indent">3. buf：环形缓冲区的指针（有指定缓冲）</p>
                <p class="one_indent">4. recvx：下一个接收操作的位置</p>
                <p class="one_indent">5. sendx：下一个发送操作的位置</p>
                <p class="one_indent">6. recvq：接收等待队列，包含等待从channel接收数据的goroutine</p>
                <p class="one_indent">7. sendq：发送等待队列，包含等待向channel发送数据的goroutine</p>
                <p class="one_indent">8. lock：互斥锁，用于保护channel数据结构的访问，防止多个goroutine同时修改channel的内部状态</p>

                <p class="col">channel缓冲与无缓冲区别</p>
                <p class="one_indent">1. 当创建一个无缓冲channel时，它不会分配用于存储元素的缓冲区。发送和接收操作将直接交换数据，并且必须同时准备好，否则操作将阻塞</p>
                <p class="one_indent">2. 有缓冲channel会分配一个环形缓冲区来存储元素。发送操作会首先尝试将数据写入缓冲区；如果缓冲区已满，则发送操作将阻塞。
                    同样，接收操作会首先尝试从缓冲区读取数据；如果缓冲区为空，则接收操作将阻塞</p>

                <p class="col">channel关闭后可以读写吗</p>
                <p class="one_indent">1. 对于无缓冲channe，关闭后可以读出零值，写则会panic</p>
                <p class="one_indent">2. 对于缓冲channe，关闭后可以读完缓冲的值，然后读零值，写则会panic</p>

                <p class="col">channel调度</p>
                <p class="one_indent">Go的运行时系统包含一个调度器，它负责协调goroutine的执行和channel的发送/接收操作。
                    调度器会根据channel的状态和等待队列中的goroutine来做出决策，以确保并发操作的高效和公平性</p>

                <p class="col">协程控制</p>
                <p class="one_indent">1. 通过channel实现协程间通信 ,select控制读写，可以通过time.After或context实现超时</p>
                <p class="one_indent">2. WaitGroup控制并发数量，通过Done()减少计数，Wait()等待所有协程完成</p>

                <p class="col">上下文context原理</p>
                <p class="one_indent">1. channel与sync.Mutext实现</p>
                <p class="one_indent">3. cancelCtx，把自己加到父级ctx的children里，cancel方法递归调用children的cancel方法，释放资源</p>

                <p class="col">WaitGroup</p>
                <p class="one_indent">Add，Done，Wait方法通过原子操作和锁实现计数</p>

                <p class="col">sync有什么锁以及区别</p>
                <p class="one_indent">1. 互斥锁sync.Mutex, 只有一个goroutine可以访问</p>
                <p class="one_indent">2. 读写锁sync.RWMutex, 读锁可以多个，写锁只能一个</p>
                <p class="one_indent">3. 条件变量sync.Cond, 用于等待条件满足</p>
                <p class="one_indent">4. 信号量sync.Semaphore, 用于控制并发数量</p>
                <p class="one_indent">5. 计数器sync.WaitGroup, 用于等待协程完成</p>
                <p class="one_indent">5. 计数器sync.Once, 用于保证初始化只执行一次</p>

                <p class="col">GMP调度</p>
                <p class="one_indent">1. G: goroutine，协程，轻量级线程，go关键字创建</p>
                <p class="one_indent">2. M: machine，机器，操作系统线程，go程序在执行时会创建很多M，M负责执行goroutine</p>
                <p class="one_indent">3. P: processor，处理器，M的执行单元，M可以绑定多个P，P可以并行执行goroutine</p>
                <p class="one_indent">4. 调度：当一个G准备执行时，会被放入P的运行队列，P会从队列中取出一个G，执行，当G执行完毕，会释放P，
                    调度器会再次尝试获取一个可执行的G，如果没有可执行的G，则阻塞在M上，等待G的唤醒</p>
                <p class="one_indent">5. 并行：当一个G被阻塞时，另一个G可以被调度到相同的P上执行，提高执行效率</p>
                <p class="one_indent">6. 并发：当一个G被阻塞时，另一个G可以被调度到不同的P上执行，提高执行效率</p>
                <p class="one_indent">7. 主动权：当一个G被阻塞时，M会主动让出P，让其他的G执行，提高执行效率</p>
                <p class="one_indent">8. 协作式调度：当一个G被阻塞时，会主动寻找其他的G，协作执行，提高执行效率</p>
                <p class="one_indent">9. 非抢占式调度：当一个G被阻塞时，不会主动让出P，而是等待调度器唤醒，提高执行效率</p>
                <p class="one_indent">10. 协程切换：当一个G执行完毕，会切换到另一个G，提高执行效率</p>
                <img src="../../assets/img/GMP.png" alt="" class="img">


                <p class="col">三色标记法</p>
                <p class="one_indent">1. 白色：未分配的内存，可以分配</p>
                <p class="one_indent">2. 灰色：已分配的内存，不能分配</p>
                <p class="one_indent">3. 黑色：已分配的内存，不能分配</p>
                <p class="one_indent">4. 初始状态：所有内存都为白色</p>
                <p class="one_indent">5. 标记过程：从根对象开始，将其直接可达对象标记为灰色，将其间接可达对象标记为灰色，直到没有灰色对象为止</p>
                <p class="one_indent">6. 回收过程：将所有未分配的白色内存释放，并将灰色内存标记为黑色</p>
                <p class="one_indent">7. 优点：不需要额外的空间，不需要额外的标记，不需要额外的遍历，只需要记录每个对象的颜色即可</p>
                <p class="one_indent">8. 缺点：不能处理循环引用，不能处理对象间的复杂关系</p>
            </div>
            <div id="box2" class="box">
                <p class="col">InnoDB与MyISAM的区别</p>
                <p class="one_indent"></p>
                
                <p class="col">索引</p>
                <p class="one_indent"></p>

                <p class="col">explain解析</p>
                <p class="one_indent"></p>

                <p class="col">sql优化</p>
                <p class="one_indent"></p>

                <p class="col">日志</p>
                <p class="one_indent"></p>

                <p class="col">事务</p>
                <p class="one_indent"></p>

                <p class="col">隔离机制</p>
                <p class="one_indent"></p>

                <p class="col">主从复制原理</p>
                <p class="one_indent"></p>

                <p class="col">锁的类型</p>
                <p class="one_indent"></p>

            </div>
            <div id="box3" class="box">
                <p class="col">缓存类型与使用场景</p>
                <p class="one_indent"></p>

                <p class="col">缓存更新策略</p>
                <p class="one_indent"></p>

                <p class="col">缓存击穿，缓存穿透，缓存雪崩</p>
                <p class="one_indent"></p>

                <p class="col">布隆过滤器</p>
                <p class="one_indent"></p>

                <p class="col">实现延时队列</p>
                <p class="one_indent"></p>

                <p class="col">keys与scan区别</p>
                <p class="one_indent"></p>

                <p class="col">主从复制原理</p>
                <p class="one_indent"></p>
            </div>
            <div id="box4" class="box">
                <p class="col">负载均衡策略</p>
                <p class="one_indent"></p>
            </div>
            <div id="box5" class="box">
                <p class="col">查询方式</p>
                <p class="one_indent"></p>
            </div>
            <div id="box6" class="box">
                <p class="col">简介</p>
                <p class="one_indent">RabbitMQ是实现了高级消息队列协议（AMQP）的开源消息代理软件（亦称面向消息的中间件）</p>

                <p class="col">使用协议</p>
                <p class="one_indent"></p>

                <p class="col">组件</p>
                <p class="one_indent"></p>

                <p class="col">工作模式</p>
                <p class="one_indent"></p>

                <p class="col">TTL队列</p>
                <p class="one_indent"></p>

                <p class="col">死信队列 (DXL)</p>
                <p class="one_indent"></p>

                <p class="col">延时队列</p>
                <p class="one_indent"></p>

                <p class="col">消息的幂等性</p>
                <p class="one_indent"></p>

                <p class="col">消息的可靠性</p>
                <p class="one_indent"></p>

                <p class="col">消息的顺序性</p>
                <p class="one_indent"></p>
            </div>
            <div id="box7" class="box">
                <p class="col">单例模式</p>
                <p class="one_indent"></p>

                <p class="col">工厂模式</p>
                <p class="one_indent"></p>

                <p class="col">抽象工厂模式</p>
                <p class="one_indent"></p>

                <p class="col">代理模式</p>
                <p class="one_indent"></p>

                <p class="col">策略模式</p>
                <p class="one_indent"></p>
            </div>
            <div id="box8" class="box">
                <p class="col">冒泡排序</p>
                <p class="one_indent"></p>

                <p class="col">快速排序</p>
                <p class="one_indent"></p>

                <p class="col">二分查找法</p>
                <p class="one_indent"></p>

                <p class="col">雪花算法</p>
                <p class="one_indent"></p>

            </div>
            <div id="box9" class="box">
                <p class="col">秒杀系统</p>
                <p class="one_indent"></p>

                <p class="col">爬虫</p>
                <p class="one_indent"></p>

                <p class="col">权限管理系统</p>
                <p class="one_indent"></p>

            </div>
            <div id="box10" class="box">
                <p class="col">组件</p>
                <p class="one_indent"></p>

                <p class="col">pod</p>
                <p class="one_indent"></p>

                <p class="col">管理</p>
                <p class="one_indent"></p>

            </div>
            <div id="box11" class="box">
                <p class="col">二叉树</p>
                <p class="one_indent"></p>

                <p class="col">红黑树</p>
                <p class="one_indent"></p>

                <p class="col">B树</p>
                <p class="one_indent"></p>

                <p class="col">B+树</p>
                <p class="one_indent"></p>

            </div>
            <div id="box12" class="box">
                <p class="col">常用指令</p>
                <p class="one_indent"></p>

            </div>
            <div id="box13" class="box">
                <p class="col">常用脚本</p>
                <p class="one_indent"></p>

            </div>
            <div id="box14" class="box">
                <p class="col">Dockerfile</p>
                <p class="one_indent"></p>

                <p class="col">Docker Compose</p>
                <p class="one_indent"></p>

            </div>
            <div id="box15" class="box">
                <p class="col">原理</p>
                <p class="one_indent"></p>

                <p class="col">配置文件</p>
                <p class="one_indent"></p>

            </div>
            <div id="box16" class="box">
                <p class="col">TCP/IP协议</p>
                <p class="one_indent"></p>

                <p class="col">UDP协议</p>
                <p class="one_indent"></p>

                <p class="col">HTTP协议</p>
                <p class="one_indent"></p>

                <p class="col">HTTPS协议</p>
                <p class="one_indent"></p>

                <p class="col">3次握手</p>
                <p class="one_indent"></p>

                <p class="col">4次挥手</p>
                <p class="one_indent"></p>

                <p class="col">验证书流程</p>
                <p class="one_indent"></p>

            </div>
            <div id="box17" class="box">
                <p class="col">鉴权原理</p>
                <p class="one_indent"></p>

            </div>
            <div id="box18" class="box">
                <p class="col">protobuf</p>
                <p class="one_indent"></p>

                <p class="col">注册与发现</p>
                <p class="one_indent">1. etcd</p>
                <p class="one_indent">2. consul</p>
                <p class="one_indent">3. zookeeper</p>

            </div>
        </div>
        <a href="javascript:history.go(-1);" class="back"></a>
    </main>
    <script>
        $(function () {
            $('.tab a').on('click', function () {
                $(this).addClass('active').siblings().removeClass('active');
                var index = $(this).index();
                $('.content .box').eq(index).addClass('selected').siblings().removeClass('selected');
                $('html, body').animate({
                    scrollTop: 0 // 0表示滚动条垂直位置的起始点
                }, 'slow'); // 'slow'定义动画执行的速度
            })
            $('.btn').on('click', function () {
                $('.tab').toggle(function () { }, function () { });
                if ($(this).hasClass('close')) {
                    $(this).removeClass('close').html('+')
                    $('.content').animate({
                        left: '0',
                        width: '100%'
                    }, 'slow'); // 'slow'定义动画执行的速度
                } else {
                    $(this).addClass('close').html('—')
                    $('.content').animate({
                        left: '30%',
                        width: '70%'
                    }, 'fast'); // 'slow'定义动画执行的速度
                }
            })
        })

    </script>
</body>

</html>